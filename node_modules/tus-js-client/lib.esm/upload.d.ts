import { type FileSource, type HttpRequest, type HttpResponse, type PreviousUpload, type UploadInput, type UploadOptions, type UrlStorage } from './options.js';
export declare const defaultOptions: {
    endpoint: null;
    uploadUrl: null;
    metadata: {};
    fingerprint: null;
    uploadSize: null;
    onProgress: null;
    onChunkComplete: null;
    onSuccess: null;
    onError: null;
    onUploadUrlAvailable: null;
    overridePatchMethod: boolean;
    headers: {};
    addRequestId: boolean;
    onBeforeRequest: null;
    onAfterResponse: null;
    onShouldRetry: typeof defaultOnShouldRetry;
    chunkSize: number;
    retryDelays: number[];
    parallelUploads: number;
    parallelUploadBoundaries: null;
    storeFingerprintForResuming: boolean;
    removeFingerprintOnSuccess: boolean;
    uploadLengthDeferred: boolean;
    uploadDataDuringCreation: boolean;
    urlStorage: null;
    fileReader: null;
    httpStack: null;
    protocol: string;
};
export default class BaseUpload {
    options: UploadOptions;
    _urlStorage: UrlStorage;
    file: UploadInput;
    url: string | null;
    _req: HttpRequest | null;
    _fingerprint: string | null;
    _urlStorageKey: string | null;
    _offset: number;
    _aborted: boolean;
    _size: number | null;
    _source: FileSource | null;
    _retryAttempt: number;
    _retryTimeout: ReturnType<typeof setTimeout> | null;
    _offsetBeforeRetry: number;
    _parallelUploads?: BaseUpload[];
    _parallelUploadUrls?: string[];
    constructor(file: UploadInput, options: UploadOptions);
    findPreviousUploads(): Promise<PreviousUpload[]>;
    resumeFromPreviousUpload(previousUpload: any): void;
    start(): void;
    /**
     * Initiate the uploading procedure for a parallelized upload, where one file is split into
     * multiple request which are run in parallel.
     *
     * @api private
     */
    _startParallelUpload(): void;
    /**
     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is
     * uploaded in a sequential matter.
     *
     * @api private
     */
    _startSingleUpload(): void;
    /**
     * Abort any running request and stop the current upload. After abort is called, no event
     * handler will be invoked anymore. You can use the `start` method to resume the upload
     * again.
     * If `shouldTerminate` is true, the `terminate` function will be called to remove the
     * current upload from the server.
     *
     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.
     * @return {Promise} The Promise will be resolved/rejected when the requests finish.
     */
    abort(shouldTerminate: any): Promise<void>;
    _emitHttpError(req: any, res: any, message: any, causingErr?: any): void;
    _emitError(err: any): void;
    /**
     * Publishes notification if the upload has been successfully completed.
     *
     * @api private
     */
    _emitSuccess(): void;
    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     *
     * @param {number} bytesSent  Number of bytes sent to the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */
    _emitProgress(bytesSent: any, bytesTotal: any): void;
    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param {number} chunkSize  Size of the chunk that was accepted by the server.
     * @param {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */
    _emitChunkComplete(chunkSize: any, bytesAccepted: any, bytesTotal: any): void;
    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */
    _createUpload(): void;
    _resumeUpload(): void;
    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */
    _performUpload(): void;
    /**
     * _addChunktoRequest reads a chunk from the source and sends it using the
     * supplied request object. It will not handle the response.
     *
     * @api private
     */
    _addChunkToRequest(req: any): Promise<HttpResponse>;
    /**
     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
     * and already have received a response.
     *
     * @api private
     */
    _handleUploadResponse(req: any, res: any): void;
    /**
     * Create a new HTTP request object with the given method and URL.
     *
     * @api private
     */
    _openRequest(method: any, url: any): any;
    /**
     * Remove the entry in the URL storage, if it has been saved before.
     *
     * @api private
     */
    _removeFromUrlStorage(): void;
    /**
     * Add the upload URL to the URL storage, if possible.
     *
     * @api private
     */
    _saveUploadInUrlStorage(): Promise<void>;
    /**
     * Send a request with the provided body.
     *
     * @api private
     */
    _sendRequest(req: HttpRequest, body?: unknown): Promise<HttpResponse>;
}
/**
 * determines if the request should be retried. Will only retry if not a status 4xx except a 409 or 423
 * @param {DetailedError} err
 * @returns {boolean}
 */
declare function defaultOnShouldRetry(err: any): boolean;
/**
 * Use the Termination extension to delete an upload from the server by sending a DELETE
 * request to the specified upload URL. This is only possible if the server supports the
 * Termination extension. If the `options.retryDelays` property is set, the method will
 * also retry if an error ocurrs.
 *
 * @param {String} url The upload's URL which will be terminated.
 * @param {object} options Optional options for influencing HTTP requests.
 * @return {Promise} The Promise will be resolved/rejected when the requests finish.
 */
export declare function terminate(url: string, options: UploadOptions): Promise<void>;
export {};
